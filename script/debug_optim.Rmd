---
title: "Optimisation sans advection"
author: " "
date: "`r Sys.Date()`"  # Affiche la date actuelle
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width = 5, fig.height = 3.5,
                      fig.align = 'center')
```


```{r lib, include=FALSE}
library(generain)
library(reshape2)
library(ggplot2)
source("load_libraries.R")
```


## Anciennes simulations

```{r}
sim_BR <- function(beta1, beta2, alpha1, alpha2, x, y, z, n.BR) { 
  ## Setup 
  RandomFields::RFoptions(spConform=FALSE) 
  lx <- length(sx <- seq_along(x)) 
  ly <- length(sy <- seq_along(y)) 
  lz <- length(sz <- seq_along(z)) 
  ## Model-Variogram BuhlCklu 
  modelBuhlCklu <- RandomFields::RMfbm(alpha=alpha1, var=beta1, proj=1) + 
                  RandomFields::RMfbm(alpha=alpha1, var=beta1, proj=2) + 
                  RandomFields::RMfbm(alpha=alpha2, var=beta2, proj=3)
  
  ## Construct grid 
  Nxy <- lx * ly 
  N <- Nxy * lz 
  grid <- matrix(0, nrow=N, ncol=3) # (N,3)-matrix 

  for (i in sx) 
    for (j in seq_len(ly*lz)) 
      grid[i+(j-1)*ly, 1] <- i 
  
  for (i in sy) 
    for (j in sx) 
      for(k in sz) 
        grid[j+lx*(i-1)+(k-1)*Nxy, 2] <- i 
  
  for (i in sz) 
    for (j in seq_len(Nxy)) 
      grid[j+Nxy*(i-1), 3] <- i

  ## Construct shifted variogram
  Varm1 <- vapply(seq_len(N), function(n) 
      RandomFields::RFvariogram(modelBuhlCklu, 
        x=sx-grid[n,1], 
        y=sy-grid[n,2], 
        z=sz-grid[n,3]), 
        array(NA_real_, dim=c(lx, ly, lz))) ## => (lx, ly, lz, N)-array 
  
  ## Main 
  Z <- array(, dim=c(lx, ly, lz, n.BR)) # 4d array 
  E <- matrix(rexp(n.BR * N), nrow=n.BR, ncol=N) 
  for (i in seq_len(n.BR)) { ## n=1 
    V <- 1/E[i,1] 
    W <- RandomFields::RFsimulate(modelBuhlCklu, x, y, z, n=1) 
    Y <- exp(W - W[1] - Varm1[,,,1]) 
    Z[,,,i] <- V * Y 
    ## n in {2,..,N} 
    for(n in 2:N) { 
      Exp <- E[i,n] 
      V <- 1/Exp 
      while(V > Z[N*(i-1)+n]) { 
        W <- RandomFields::RFsimulate(modelBuhlCklu, x, y, z) 
        Y <- exp(W - W[n] - Varm1[,,,n]) 
        if(all(V*Y[seq_len(n-1)] < Z[(N*(i-1)+1):(N*(i-1)+(n-1))])) 
          Z[,,,i] <- pmax(V*Y, Z[,,,i]) 
          Exp <- Exp + rexp(1) 
          V <- 1/Exp 
      } 
    } 
  } 
  ## Return 
  Z 
}
```


```{r}
true_param <- c(0.4, 0.2, 1.5, 1)
ngrid <- 5
spa <- 1:ngrid
nsites <- ngrid^2 # if the grid is squared
temp <- 1:300
n.BR <- 1

# generate the simulations
# BR <- sim_BR(true_param[1] * 2, true_param[2] * 2, true_param[3], true_param[4],
#              spa, spa, temp, n.BR)
# save_simulations(BR, ngrid, n.BR,
#         folder = paste0("../data/simulations_BR/oldsim_", ngrid^2, "s_",
#                                 length(temp), "t/"),
#                   file = paste0("br_", ngrid^2, "s_",
#                                 length(temp), "t"), forcedind = 1)

# load the simulations
file_path <- paste0("../data/simulations_BR/oldsim_", ngrid^2, "s_",
                                length(temp), "t/br_",
                      ngrid^2, "s_", length(temp), "t_", 1, ".csv")
simu_df <- read.csv(file_path)
```


```{r}
nsites <- ncol(simu_df)
sites_coords <- generate_grid_coords(sqrt(nsites))
dist_mat <- get_dist_mat(sites_coords,
                         latlon = FALSE) # distance matrix
df_dist <- reshape_distances(dist_mat) # reshape the distance matrix
```

## Validation du modèle de Buhl séparable

Pour la simulation avec 25 sites et 300 pas de temps
et un quantile de 0.9 on obtient une bonne estimation des
paramètres du modèle de Buhl séparable avec WLSE.

En revanche, pour une simulation avec 49 sites et 300 pas de temps avec un quantile de 0.9
on obtient une mauvaise estimation notamment pour le paramètre \(\beta_1\) et le choix
du quantile a un impact sur l'estimation des paramètres mais aucune valeur de quantile ne 
permet une bonne estimation de tous les paramètres.

```{r}
sites_coords <- generate_grid_coords(sqrt(nsites))
h_vect <- get_lag_vectors(sites_coords, true_param,
                          hmax = sqrt(17), tau_vect = 0:10)

hmax <- sqrt(17)
q <- 0.9
chispa <- spatial_chi_alldist(df_dist, simu_df, quantile = q,
                               hmax = hmax)
spa_estim <- get_estimate_variospa(chispa, weights = "exp", summary = FALSE)
print(spa_estim)

q <- 0.9
tmax <- 10
chitemp <- temporal_chi(simu_df, tmax = tmax, quantile = q)
temp_estim <- get_estimate_variotemp(chitemp, tmax, npoints = ncol(simu_df),
                                      weights = "exp", summary = FALSE)
print(temp_estim)
df_result <- data.frame(beta1 =  spa_estim[1],
                        alpha1 = spa_estim[2],
                        beta2 = temp_estim[1],
                        alpha2 = temp_estim[2])
colnames(df_result) <- c("beta1", "alpha1", "beta2", "alpha2")

df_valid <- get_criterion(df_result, true_param)
colnames(df_valid) <- c("estim", "rmse", "mae")
print(df_valid)
```


## Optimisation

### Get excesses

```{r}
empirical_excesses <- function(data_rain, quantile, h_vect) {
  q <- quantile # quantile

  unique_tau <- unique(h_vect$tau) # unique temporal lags

  for (t in unique_tau) { # loop over temporal lags
    df_h_t <- h_vect[h_vect$tau == t, ] # get the dataframe for each lag

    for (i in seq_len(nrow(df_h_t))) { # loop over each pair of sites
      # get the indices of the sites
      ind_s2 <- as.numeric(as.character(df_h_t$s2[i]))
      ind_s1 <- df_h_t$s1[i]

      # get the data for the pair of sites
      rain_cp <- data_rain[, c(ind_s1, ind_s2), drop = FALSE]
      rain_cp <- na.omit(rain_cp)
      colnames(rain_cp) <- c("s1", "s2")

      Tmax <- nrow(rain_cp) # number of time steps
      rain_nolag <- rain_cp$s1[1:(Tmax - t)] # get the data without lag
      rain_lag <- rain_cp$s2[(1 + t):Tmax] # get the data with lag

      n <- length(rain_nolag) # number of observations
      # transform the data in uniform data
      rain_unif <- cbind(rank(rain_nolag) / (n + 1), rank(rain_lag) / (n + 1))
      # get the conditional excesses on s2
      cp_cond <- rain_unif[rain_unif[, 2] > q, , drop = FALSE]
      excess_count <- sum(cp_cond[, 1] > q) # number of excesses for s1 given
                                            # those of s2
      num_cond_excesses <- nrow(cp_cond) # number excesses for s2

      # store the number of excesses
      h_vect$N_vect[h_vect$s1 == ind_s1 & h_vect$s2 == ind_s2 & h_vect$tau == t] <- num_cond_excesses
      h_vect$n_vect[h_vect$s1 == ind_s1 & h_vect$s2 == ind_s2 & h_vect$tau == t] <- excess_count
    }
  }
  return(h_vect)
}

q <- 0.9
excesses <- empirical_excesses(simu_df, q, h_vect)
print(head(excesses))

# density plot of the number of excesses
ggplot(excesses, aes(x = n_vect)) +
  geom_density() +
  labs(title = "Density plot of the number of excesses",
       x = "Number of excesses", y = "Density")
 
```


Pour la simulation avec 25 sites et 300 pas de temps
avec un quantile de 0.9 on obtient une bonne 
estimation des paramètres du modèle de Buhl séparable avec l'optimisation
de la vraisemblance composite.
En changeant le quantile, on garde des résultats similaires pour \(q > 0.9\) et proche de 0.9.
Pour \(q < 0.9\), on obtient des résultats moins bons pour le paramètre \(\alpha_1\).


Pour la simulation avec 49 sites et 300 pas de temps
avec un quantile de 0.9 on obtient une mauvaise 
estimation des paramètres du modèle  avec l'optimisation
de la vraisemblance composite. Les alphas sont fortement sous-estimés.

Peu importe la méthode d'optimisation, on obtient des résultats similaires.

```{r}
tau_vect <- unique(h_vect$tau)
result <- optim(par = c(true_param), fn = neg_ll,
                        simu = simu_df,
                        quantile = q,
                        excesses = excesses,
                        h_vect = h_vect, tau = tau_vect,
                        locations = sites_coords,
                        method = "CG",
                        control = list(parscale = c(1, 1, 1, 1),
                                        maxit = 10000))
print(result$convergence) # 0 if it has converged
print(result$par)

rmse <- sqrt((result$par - true_param)^2)
df_rmse <- data.frame(estim = result$par, rmse = rmse)
rownames(df_rmse) <- c("beta1", "beta2", "alpha1", "alpha2")
print(t(df_rmse))
```

## Ajout de l'advection dans la simulation

```{r}
sim_BR <- function(beta1, beta2, alpha1, alpha2, x, y, z, n.BR) { 
  ## Setup 
  RandomFields::RFoptions(spConform=FALSE) 
  lx <- length(sx <- seq_along(x)) 
  ly <- length(sy <- seq_along(y)) 
  lz <- length(sz <- seq_along(z)) 
  ## Model-Variogram BuhlCklu 
  modelBuhlCklu <- RandomFields::RMfbm(alpha=alpha1, var=beta1, proj=1) + 
                  RandomFields::RMfbm(alpha=alpha1, var=beta1, proj=2) + 
                  RandomFields::RMfbm(alpha=alpha2, var=beta2, proj=3)
  
  ## Construct grid 
  Nxy <- lx * ly 
  N <- Nxy * lz 
  grid <- matrix(0, nrow=N, ncol=3) # (N,3)-matrix 

  for (i in sx) 
    for (j in seq_len(ly*lz)) 
      grid[i+(j-1)*ly, 1] <- i 
  
  for (i in sy) 
    for (j in sx) 
      for(k in sz) 
        grid[j+lx*(i-1)+(k-1)*Nxy, 2] <- i 
  
  for (i in sz) 
    for (j in seq_len(Nxy)) 
      grid[j+Nxy*(i-1), 3] <- i

  ## Construct shifted variogram
  Varm1 <- vapply(seq_len(N), function(n) 
      RandomFields::RFvariogram(modelBuhlCklu, 
        x=sx-grid[n,1], 
        y=sy-grid[n,2], 
        z=sz-grid[n,3]), 
        array(NA_real_, dim=c(lx, ly, lz))) ## => (lx, ly, lz, N)-array 
  
  ## Main 
  Z <- array(, dim=c(lx, ly, lz, n.BR)) # 4d array 
  E <- matrix(rexp(n.BR * N), nrow=n.BR, ncol=N) 
  for (i in seq_len(n.BR)) { ## n=1 
    V <- 1/E[i,1] 
    W <- RandomFields::RFsimulate(modelBuhlCklu, x, y, z, n=1) 
    Y <- exp(W - W[1] - Varm1[,,,1]) 
    Z[,,,i] <- V * Y 
    ## n in {2,..,N} 
    for(n in 2:N) { 
      Exp <- E[i,n] 
      V <- 1/Exp 
      while(V > Z[N*(i-1)+n]) { 
        W <- RandomFields::RFsimulate(modelBuhlCklu, x, y, z) 
        Y <- exp(W - W[n] - Varm1[,,,n]) 
        if(all(V*Y[seq_len(n-1)] < Z[(N*(i-1)+1):(N*(i-1)+(n-1))])) 
          Z[,,,i] <- pmax(V*Y, Z[,,,i]) 
          Exp <- Exp + rexp(1) 
          V <- 1/Exp 
      } 
    } 
  } 
  ## Return 
  Z 
}
```