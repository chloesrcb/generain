---
title: "Model on Montpellier rainfall"
author: " "
date: "`r Sys.Date()`" 
output:
  pdf_document:
    extra_dependencies: ["float"]
    encoding: "UTF-8"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width = 7, fig.height = 7,
                      fig.align = 'center', message = FALSE, warning = FALSE,
                      fig.pos='H')
par(cex.main = 0.8,
    cex.lab = 0.7,
    cex.axis = 0.6)
```


```{r lib, echo=FALSE}
# setwd("./script")
library(generain)
library(reshape2)
library(ggplot2)
source("load_libraries.R")
library(kableExtra)
library(extRemes)
library(bbmle)
library(ismev)
library(extRemes)
library(evd)
```

```{r}
################################################################################
# LOCATION ---------------------------------------------------------------------
################################################################################
# get location of each rain gauge
location_gauges <- read.csv("../data/PluvioMontpellier_1min/pluvio_mtp_loc.csv")
location_gauges$codestation <- c("iem", "mse", "poly", "um", "cefe", "cnrs",
                                 "crbm", "archiw", "archie", "um35", "chu1",
                                 "chu2", "chu3", "chu4", "chu5", "chu6", "chu7")

# Get distances matrix
dist_mat <- get_dist_mat(location_gauges)
df_dist <- reshape_distances(dist_mat)

################################################################################
# DATA -------------------------------------------------------------------------
################################################################################
# get rain measurements
# load data
load("../data/PluvioMontpellier_1min/rain_mtp_5min_2019_2022.RData")
rain <- rain.all5[c(1, 6:ncol(rain.all5))]
```


```{r}
# spatial structure with an almost constant amount of pairs in each intervals
df_dist_order <- df_dist[order(df_dist$value), ]
num_intervals <- 10
quantiles_rad <- quantile(df_dist_order$value,
                            probs = seq(0, 1, length.out = num_intervals + 1))
radius_intervals <- unique(quantiles_rad)
radius <- as.integer(radius_intervals)
radius[length(radius)] <- 1550
dist_counts <- table(cut(df_dist$value, breaks = radius))

# Get dataframe for the histogram plot
df_hist <- data.frame(dist_counts)

colnames(df_hist) <- c("Interval", "Count")

df_hist$Breaks <- gsub("e\\+0.", "0", df_hist$Interval)
df_hist$Breaks <- gsub("\\.", "", df_hist$Breaks)

# # Histogram
histradius <- ggplot(df_hist, aes(x = Interval, y = Count)) +
  btf_theme +
  geom_bar(stat = "identity", fill = btfgreen, alpha = 0.8) +
  xlab("Spatial lag") +
  ylab("Pair count") +
  theme(axis.text.x = element_text(angle = 45)) +
  scale_x_discrete(labels = df_hist$Breaks) +
  scale_y_continuous(breaks = c(0, 4, 6, 8, 10, 12))

histradius

# Create matrix of radius
rad_mat <- dist_mat
# Loop through radius and set distances in matrix
for (i in 2:length(radius)) {
  curr_radius <- radius[i]
  prev_radius <- radius[i - 1]
  rad_mat[dist_mat >= prev_radius & dist_mat < curr_radius] <- curr_radius
  rad_mat[dist_mat > curr_radius] <- Inf
}

rad_mat[dist_mat == 0] <- 0
# Make a triangle
rad_mat[lower.tri(rad_mat)] <- NA
```

```{r}
# get the empirical chi
q <- 0.998
rain_new <- rain[-1]
chispa <- spatial_chi(rad_mat, rain_new, quantile = q)
spa_estim <- get_estimate_variospa(chispa, weights = "exp", summary = TRUE)

q <- 0.998
tmax <- 10
chitemp <- temporal_chi(rain, tmax = tmax, quantile = q)
temp_estim <- get_estimate_variotemp(chitemp, tmax, npoints = ncol(rain),
                                      weights = "exp", summary = TRUE)

df_result <- data.frame(beta1 =  spa_estim[1],
                        beta2 = temp_estim[1],
                        alpha1 = spa_estim[2],
                        alpha2 = temp_estim[2])

colnames(df_result) <- c("beta1", "alpha1", "beta2", "alpha2")

kable(df_result, format = "latex") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed",
  "responsive"), latex_options = "H")
```


## Optimisation

```{r}
# Get coords
sites_coords <- location_gauges[, c("X", "Y")]
names(sites_coords) <- c("Lon", "Lat")

# Choose a conditional spatio-temporal point
s0 <- c(sites_coords[1, ]) # get coords
t0 <- 1

# get lags
df_lags <- get_conditional_lag_vectors(sites_coords, s0, t0, tau_max = 10)

u <- 1
list_excesses <- list()
# par(mfrow=c(5, 2))
for (i in 1:m) {
  list_excesses[[i]] <- empirical_excesses(list_simu[[i]], u, df_lags,
                                     threshold = TRUE, type="rpareto", t0=1)
}

true_param <- c(params, adv)
result <- optim(par = true_param, fn = neg_ll_composite,
                  list_simu = list_simu,
                  quantile = u,
                  df_lags = df_lags,
                  list_excesses = list_excesses,
                  hmax = sqrt(17),
                  s0 = s0,
                  t0 = t0,
                  threshold = TRUE,
                  # method = "CG",
                  method = "L-BFGS-B",
                  lower = c(1e-6, 1e-6, 1e-6, 1e-6, -Inf, -Inf),
                  upper = c(Inf, Inf, 1.999, 1.999, Inf, Inf),
                  control = list(maxit = 10000))


df_result <- data.frame(beta1 =  result$par[1],
                        beta2 = result$par[2],
                        alpha1 = result$par[3],
                        alpha2 = result$par[4],
                        adv1 = result$par[5],
                        adv2 = result$par[6])
```